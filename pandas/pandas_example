import pandas as pd

def big_countries(world: pd.DataFrame) -> pd.DataFrame:
    df = world[(world['area'] >= 3000000) | (world['population'] >= 25000000)]
    return df[['name','population','area']]


import pandas as pd

def find_products(products: pd.DataFrame) -> pd.DataFrame:
    df = products[(products['low_fats'] == 'Y') & (products['recyclable'] == 'Y')]
    return df[['product_id']]


# Write your MySQL query statement below
# SELECT name as Customers
# FROM Customers
# INNER JOIN Orders
# ON Customers.id = Orders.customerId

#The above inner join won't work as it will not give us the desired names, instead the complete opposite


# Sol1
# SELECT name as Customers
# FROM Customers
# WHERE Customers.id NOT IN (SELECT customerId from Orders)

# #Sol2
# Select name as customers
# FROM Customers
# LEFT JOIN Orders
# On Customers.id= Orders.customerId
# WHERE customerId is NULL

#Sol3
SELECT name as Customers
FROM Customers
WHERE NOT EXISTS (SELECT 1 FROM orders WHERE Customers.id= Orders.customerId)


import pandas as pd

def find_customers(customers: pd.DataFrame, orders: pd.DataFrame) -> pd.DataFrame:
    # df = customers[~customers['id'].isin(orders['customerId'])]
    # df = df[['name']].rename(columns={'name':'Customers'})
    # return df

    #sol2
    df = customers.merge(orders, left_on='id', right_on='customerId', how='left')
    df = df[df['customerId'].isna()]
    df = df[['name']].rename(columns={'name': 'Customers'})
    return df



Q.4
# Write your MySQL query statement below
Select DISTINCT author_id as id
from Views
where author_id=viewer_id ORDER BY author_id

import pandas as pd

def article_views(views: pd.DataFrame) -> pd.DataFrame:
    df = views[views['author_id']==views['viewer_id']]
    df = df[['author_id']].rename(columns={'author_id':'id'})
    df = df.sort_values(by='id')
    return df.drop_duplicates()

Q.5

import pandas as pd

def invalid_tweets(tweets: pd.DataFrame) -> pd.DataFrame:
    df = tweets[tweets['content'].str.len() > 15]
    return df[['tweet_id']]

select tweet_id
from Tweets
WHERE CHAR_LENGTH(content)>15


Q.6
# Write your MySQL query statement below
SELECT employee_id, IF(employee_id%2!=0 AND name NOT LIKE 'M%',salary,0) as bonus
FROM Employees
ORDER BY employee_id


def calculate_special_bonus(employees: pd.DataFrame) -> pd.DataFrame:
   # Create a new column 'bonus' with default value 0
    employees['bonus'] = 0

    # Calculate bonus based on the conditions
    employees.loc[(employees['employee_id'] % 2 != 0) & (~employees['name'].str.startswith('M')), 'bonus'] = employees['salary']

    # Select only the required columns and sort the result table by employee_id in ascending order
    result_df = employees[['employee_id', 'bonus']].sort_values(by='employee_id', ascending=True)

    return result_df

Q.7
# Write your MySQL query statement below
Select user_id , CONCAT(UPPER(SUBSTR(name,1,1)),LOWER(SUBSTR(name,2))) as name
FROM users
ORDER BY user_id

import pandas as pd

def fix_names(users: pd.DataFrame) -> pd.DataFrame:
    users['name'] =  users['name'].str.capitalize()
    df = users.sort_values(by='user_id', ascending=True)
    return df[['user_id','name']]

Without using capitalize

# Solution 2
def fix_names(users: pd.DataFrame) -> pd.DataFrame:
    users['str1'] = users['name'].str.slice(0,1).str.upper()
    # print( users['str1'])
    users['str2'] = users['name'].str.slice(1).str.lower()
    # print( users['str2'])
    users['name'] = users['str1'] + users['str2']
    df = users.sort_values(by='user_id', ascending=True)
    return df[['user_id','name']]

Q.8

SELECT
  *
FROM
  Users
WHERE
  mail REGEXP '^[a-zA-Z][a-zA-Z0-9_.-]*@leetcode[.]com$';

import pandas as pd

def valid_emails(users: pd.DataFrame) -> pd.DataFrame:
    users = users[users['mail'].str.match(r'^[A-Za-z][\w.-]*@leetcode\.com')]
    return users

Q,9
SELECT * FROM patients WHERE conditions REGEXP '\\bDIAB1'
or
SELECT * FROM PATIENTS WHERE
CONDITIONS LIKE '% DIAB1%' OR
CONDITIONS LIKE 'DIAB1%';

import pandas as pd

def find_patients(patients: pd.DataFrame) -> pd.DataFrame:
    patients_with_diabetes = patients[patients['conditions'].str.contains(r'\bDIAB1')]
    result_df = patients_with_diabetes[['patient_id', 'patient_name', 'conditions']]
    return result_df

Q.
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
SET N = N-1;
  RETURN (
      SELECT DISTINCT(salary) from Employee order by salary DESC
      LIMIT 1 OFFSET N

  );
END

#Sol2
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
DECLARE Result INT;

SET N = N-1;

SELECT DISTINCT(salary) into Result from Employee order by salary DESC
      LIMIT 1 OFFSET N;
  RETURN (

      result
  );
END

#sol3
import pandas as pd

def nth_highest_salary(employee: pd.DataFrame, N: int) -> pd.DataFrame:

    # Drop any duplicate salary values to avoid counting duplicates as separate salary ranks
    unique_salaries = employee['salary'].drop_duplicates()

    # Sort the unique salaries in descending order and get the Nth highest salary
    sorted_salaries = unique_salaries.sort_values(ascending=False)

    # If N exceeds the number of unique salaries, return None
    if N > len(sorted_salaries):
        return pd.DataFrame({'getNthHighestSalary(2)': [None]})

    # Get the Nth highest salary from the sorted salaries
    nth_highest = sorted_salaries.iloc[N - 1]

    return pd.DataFrame({'getNthHighestSalary(2)': [nth_highest]})


#Final Working sol
import pandas as pd

def nth_highest_salary(employee: pd.DataFrame, N: int) -> pd.DataFrame:
    sorted_salary = employee['salary'].sort_values(ascending=False).drop_duplicates()
    if N > len(sorted_salary):
        return pd.DataFrame({f'getNthHighestSalary({N})': [None]})
    nth_highest = sorted_salary.iloc[N-1]
    return pd.DataFrame({f'getNthHighestSalary({N})': [nth_highest]})